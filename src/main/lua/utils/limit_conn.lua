---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Administrator.
--- DateTime: 2023/10/12 11:23
---
local limit_conn = require "resty.limit.conn"

--限制200个并发请求下的请求和一个100个并发的额外的突发请求。也就是我们延迟
--请求300个并发连接以内以及200个以上连接，并拒绝任何超过300的新请求连接。
--另外，我们假设默认请求时间为0.5秒，也就是说通过下面的log_by_lua中的leaving（）调用动态调整。
--以上是官网给的配置参数的的说明介绍。("my_limit_conn_store", 200, 100, 0.5) 这个是官网给的参数

-- new 的第四个参数用于估算每个请求会维持多长时间，以便于应用漏桶算法
local limit, limit_err = limit_conn.new("limit_conn_store",  1, 0, 0.5)
if not limit then
    error("failed to instantiate a resty.limit.conn object: ", limit_err)
end

local _M = {}

function _M.incoming()
    local key = ngx.var.binary_remote_addr
    local delay, err = limit:incoming(key, true)
    if not delay then
        if err == "rejected" then
            return ngx.exit(503)
        end
        ngx.log(ngx.ERR, "failed to limit req: ", err)
        return ngx.exit(500)
    end

    if limit:is_committed() then
        local ctx = ngx.ctx
        ctx.limit_conn_key = key
        ctx.limit_conn_delay = delay
    end

    if delay >= 0.001 then
        ngx.log(ngx.WARN, "delaying conn, excess ", delay,
                "s per binary_remote_addr by limit_conn_store")
        ngx.sleep(delay)
    end
end

function _M.leaving()
    local ctx = ngx.ctx
    local key = ctx.limit_conn_key
    if key then
        local latency = tonumber(ngx.var.request_time) - ctx.limit_conn_delay
        local conn, err = limit:leaving(key, latency)
        if not conn then
            ngx.log(ngx.ERR,
                    "failed to record the connection leaving ",
                    "request: ", err)
        end
    end
end

return _M